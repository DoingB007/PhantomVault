// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.27;

import {FHE, euint64, ebool, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {SepoliaConfig} from "@fhevm/solidity/config/ZamaConfig.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {IERC20} from "@openzeppelin/contracts/interfaces/IERC20.sol";
import {cUSDT} from "./cUSDT.sol";
import {CSecretStakeCoin} from "./cSecretStakeCoin.sol";

contract SecretStakePlatform is SepoliaConfig, Ownable, ReentrancyGuard {
    using FHE for euint64;
    using FHE for ebool;

    // Token contracts
    cUSDT public immutable stakingToken;
    CSecretStakeCoin public immutable rewardToken;
    IERC20 public immutable underlyingUSDT;

    // Reward configuration
    uint256 public constant REWARD_PER_BLOCK = 1e18; // 1 cSSC per block
    uint256 public lastRewardBlock;
    euint64 public totalStaked;
    euint64 public accRewardPerShare; // Accumulated reward per share, scaled by 1e12

    // User staking info
    struct UserInfo {
        euint64 stakedAmount;     // Encrypted staked amount
        euint64 rewardDebt;       // Encrypted reward debt for reward calculation
        uint256 lastStakeBlock;   // Block number of last stake action
    }

    mapping(address => UserInfo) public userInfo;
    mapping(address => uint256) public userStakeCount; // For tracking user activity

    // Events
    event Staked(address indexed user, uint256 blockNumber);
    event Withdrawn(address indexed user, uint256 blockNumber);
    event RewardClaimed(address indexed user, uint256 blockNumber);
    event RewardPoolUpdated(uint256 blockNumber);

    // Error tracking for FHE operations
    struct LastError {
        euint64 error;
        uint256 timestamp;
    }
    mapping(address => LastError) private _lastErrors;

    // Error codes
    euint64 internal NO_ERROR;
    euint64 internal INSUFFICIENT_BALANCE;
    euint64 internal INVALID_AMOUNT;

    constructor(
        address _underlyingUSDT,
        address _stakingToken,
        address _rewardToken
    ) Ownable(msg.sender) {
        underlyingUSDT = IERC20(_underlyingUSDT);
        stakingToken = cUSDT(_stakingToken);
        rewardToken = CSecretStakeCoin(_rewardToken);
        
        lastRewardBlock = block.number;
        totalStaked = euint64.wrap(bytes32(0));
        accRewardPerShare = euint64.wrap(bytes32(0));

        // Initialize error codes
        NO_ERROR = euint64.wrap(bytes32(0));
        INSUFFICIENT_BALANCE = euint64.wrap(bytes32(uint256(1)));
        INVALID_AMOUNT = euint64.wrap(bytes32(uint256(2)));
    }

    // Update reward pool - distributes rewards based on blocks passed
    function updatePool() public {
        if (block.number <= lastRewardBlock) {
            return;
        }

        // Always calculate rewards - FHE operations will handle zero cases automatically
        uint256 blocksPassed = block.number - lastRewardBlock;
        uint256 totalRewards = blocksPassed * REWARD_PER_BLOCK;
        
        // Only calculate if total rewards > 0
        if (totalRewards > 0) {
            // Calculate reward per share: (totalRewards * 1e12) / totalStaked
            // Use select to avoid division by zero
            ebool hasStakers = FHE.gt(totalStaked, 0);
            euint64 rewardPerShareIncrease = FHE.select(
                hasStakers,
                FHE.div(FHE.mul(euint64.wrap(bytes32(totalRewards)), 1e12), totalStaked),
                euint64.wrap(bytes32(0))
            );
            
            accRewardPerShare = FHE.add(accRewardPerShare, rewardPerShareIncrease);
            
            // Mint rewards to this contract for distribution
            rewardToken.mint(address(this), euint64.wrap(bytes32(totalRewards)));
        }

        lastRewardBlock = block.number;
        emit RewardPoolUpdated(block.number);
    }

    // Stake cUSDT tokens
    function stake(
        externalEuint64 _encryptedAmount,
        bytes calldata _inputProof
    ) external nonReentrant {
        updatePool();

        // Validate and convert external input
        euint64 amount = FHE.fromExternal(_encryptedAmount, _inputProof);
        
        // Check if amount is valid (> 0)
        ebool isValidAmount = FHE.gt(amount, 0);
        
        // Get user's current balance
        euint64 userBalance = stakingToken.balanceOf(msg.sender);
        ebool hasSufficientBalance = FHE.ge(userBalance, amount);
        
        // Combine all conditions
        ebool canStake = FHE.and(isValidAmount, hasSufficientBalance);
        
        // Set error based on conditions
        euint64 errorCode = FHE.select(
            canStake,
            NO_ERROR,
            FHE.select(isValidAmount, INSUFFICIENT_BALANCE, INVALID_AMOUNT)
        );
        setLastError(errorCode, msg.sender);

        // Get user info
        UserInfo storage user = userInfo[msg.sender];
        
        // Calculate pending rewards before updating user info
        euint64 pending = FHE.select(
            FHE.gt(user.stakedAmount, 0),
            FHE.sub(
                FHE.div(FHE.mul(user.stakedAmount, accRewardPerShare), 1e12),
                user.rewardDebt
            ),
            euint64.wrap(bytes32(0))
        );

        // Transfer staking tokens from user (conditional transfer)
        euint64 transferAmount = FHE.select(canStake, amount, euint64.wrap(bytes32(0)));
        FHE.allowTransient(transferAmount, address(stakingToken));
        stakingToken.transferFrom(msg.sender, address(this), transferAmount);

        // Update user staked amount
        user.stakedAmount = FHE.add(user.stakedAmount, transferAmount);
        
        // Update total staked
        totalStaked = FHE.add(totalStaked, transferAmount);
        
        // Update reward debt
        user.rewardDebt = FHE.div(FHE.mul(user.stakedAmount, accRewardPerShare), 1e12);
        user.lastStakeBlock = block.number;
        
        // Increment stake count
        userStakeCount[msg.sender]++;

        // Send pending rewards if any
        ebool hasPendingRewards = FHE.gt(pending, 0);
        euint64 rewardToSend = FHE.select(hasPendingRewards, pending, euint64.wrap(bytes32(0)));
        FHE.allowTransient(rewardToSend, address(rewardToken));
        rewardToken.transfer(msg.sender, rewardToSend);

        // Grant ACL permissions
        FHE.allowThis(user.stakedAmount);
        FHE.allow(user.stakedAmount, msg.sender);
        FHE.allowThis(user.rewardDebt);
        FHE.allowThis(totalStaked);
        FHE.allowThis(accRewardPerShare);

        emit Staked(msg.sender, block.number);
    }

    // Withdraw staked tokens
    function withdraw(
        externalEuint64 _encryptedAmount,
        bytes calldata _inputProof
    ) external nonReentrant {
        updatePool();

        // Validate and convert external input
        euint64 amount = FHE.fromExternal(_encryptedAmount, _inputProof);
        
        UserInfo storage user = userInfo[msg.sender];
        
        // Check if amount is valid and user has sufficient staked amount
        ebool isValidAmount = FHE.gt(amount, 0);
        ebool hasSufficientStake = FHE.ge(user.stakedAmount, amount);
        ebool canWithdraw = FHE.and(isValidAmount, hasSufficientStake);

        // Set error based on conditions
        euint64 errorCode = FHE.select(
            canWithdraw,
            NO_ERROR,
            FHE.select(isValidAmount, INSUFFICIENT_BALANCE, INVALID_AMOUNT)
        );
        setLastError(errorCode, msg.sender);

        // Calculate pending rewards
        euint64 pending = FHE.select(
            FHE.gt(user.stakedAmount, 0),
            FHE.sub(
                FHE.div(FHE.mul(user.stakedAmount, accRewardPerShare), 1e12),
                user.rewardDebt
            ),
            euint64.wrap(bytes32(0))
        );

        // Conditional withdrawal
        euint64 withdrawAmount = FHE.select(canWithdraw, amount, euint64.wrap(bytes32(0)));
        
        // Update user staked amount
        user.stakedAmount = FHE.sub(user.stakedAmount, withdrawAmount);
        
        // Update total staked
        totalStaked = FHE.sub(totalStaked, withdrawAmount);
        
        // Update reward debt
        user.rewardDebt = FHE.div(FHE.mul(user.stakedAmount, accRewardPerShare), 1e12);

        // Transfer staked tokens back to user
        FHE.allowTransient(withdrawAmount, address(stakingToken));
        stakingToken.transfer(msg.sender, withdrawAmount);

        // Send pending rewards
        ebool hasPendingRewards = FHE.gt(pending, 0);
        euint64 rewardToSend = FHE.select(hasPendingRewards, pending, euint64.wrap(bytes32(0)));
        FHE.allowTransient(rewardToSend, address(rewardToken));
        rewardToken.transfer(msg.sender, rewardToSend);

        // Grant ACL permissions
        FHE.allowThis(user.stakedAmount);
        FHE.allow(user.stakedAmount, msg.sender);
        FHE.allowThis(user.rewardDebt);
        FHE.allowThis(totalStaked);

        emit Withdrawn(msg.sender, block.number);
    }

    // Claim pending rewards without withdrawing staked amount
    function claimRewards() external nonReentrant {
        updatePool();

        UserInfo storage user = userInfo[msg.sender];
        
        // Calculate pending rewards
        euint64 pending = FHE.select(
            FHE.gt(user.stakedAmount, 0),
            FHE.sub(
                FHE.div(FHE.mul(user.stakedAmount, accRewardPerShare), 1e12),
                user.rewardDebt
            ),
            euint64.wrap(bytes32(0))
        );

        // Update reward debt
        user.rewardDebt = FHE.div(FHE.mul(user.stakedAmount, accRewardPerShare), 1e12);

        // Transfer pending rewards
        ebool hasPendingRewards = FHE.gt(pending, 0);
        euint64 rewardToSend = FHE.select(hasPendingRewards, pending, euint64.wrap(bytes32(0)));
        FHE.allowTransient(rewardToSend, address(rewardToken));
        rewardToken.transfer(msg.sender, rewardToSend);

        // Grant ACL permissions
        FHE.allowThis(user.rewardDebt);

        emit RewardClaimed(msg.sender, block.number);
    }

    // View functions
    function getUserStakedAmount(address _user) external view returns (euint64) {
        return userInfo[_user].stakedAmount;
    }

    function getUserRewardDebt(address _user) external view returns (euint64) {
        return userInfo[_user].rewardDebt;
    }

    function getTotalStaked() external view returns (euint64) {
        return totalStaked;
    }

    function getAccRewardPerShare() external view returns (euint64) {
        return accRewardPerShare;
    }

    // Calculate pending rewards for a user
    function pendingRewards(address _user) external view returns (euint64) {
        UserInfo memory user = userInfo[_user];
        
        // Always calculate pending rewards, let FHE handle zero cases

        euint64 currentAccRewardPerShare = accRewardPerShare;
        
        // Calculate what the accRewardPerShare would be if we updated now
        if (block.number > lastRewardBlock) {
            uint256 blocksPassed = block.number - lastRewardBlock;
            uint256 totalRewards = blocksPassed * REWARD_PER_BLOCK;
            
            euint64 rewardPerShareIncrease = FHE.div(
                FHE.mul(euint64.wrap(bytes32(totalRewards)), 1e12),
                totalStaked
            );
            
            currentAccRewardPerShare = FHE.add(accRewardPerShare, rewardPerShareIncrease);
        }

        return FHE.sub(
            FHE.div(FHE.mul(user.stakedAmount, currentAccRewardPerShare), 1e12),
            user.rewardDebt
        );
    }

    // Error handling functions
    function setLastError(euint64 error, address user) private {
        _lastErrors[user] = LastError(error, block.timestamp);
        emit ErrorChanged(user);
    }

    function getLastError(address user) external view returns (euint64, uint256) {
        LastError memory lastError = _lastErrors[user];
        return (lastError.error, lastError.timestamp);
    }

    // Events
    event ErrorChanged(address indexed user);

    // Emergency functions (onlyOwner)
    function emergencyWithdraw() external onlyOwner {
        // Allow owner to withdraw any tokens in case of emergency
        uint256 stakingBalance = stakingToken.balanceOf(address(this));
        uint256 rewardBalance = rewardToken.balanceOf(address(this));
        
        if (stakingBalance > 0) {
            stakingToken.transfer(owner(), euint64.wrap(bytes32(stakingBalance)));
        }
        if (rewardBalance > 0) {
            rewardToken.transfer(owner(), euint64.wrap(bytes32(rewardBalance)));
        }
    }

    function updateRewardPerBlock(uint256 _newRewardPerBlock) external onlyOwner {
        updatePool();
        // Note: In a real implementation, you might want to make REWARD_PER_BLOCK a state variable
        // For now, this is just a placeholder for the interface
    }
}